/*********************************************************************************  Project 2**  Programmers: Madison Solarana, Tyler Morrow, Stephen Schwartz, **               Daniel Pham & Brian Yarbrough**********************************************************************************  Takes input from a 4x4 keypad and preforms basic math operations, displaying**  the output on the computer screen.*******************************************************************************/// ***  Includes  **************************************************************#include <reg922.h>// ***  Prototypes  ************************************************************void init(void);void welcome(void);void sendCharToPC(char);void sendStringToPC(char *);void delay(unsigned short);void groundKeypad(void);void checkColumnOne(void);void checkColumnTwo(void);void checkColumnThree(void);void checkColumnFour(void);void clear(void);void error(char *);void saveDecimal();void saveOperand(unsigned short);void saveOperation(char);void equate(void);char * float_to_string(float);// ***  Global Variables  ******************************************************char charValues[10] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};const unsigned short KEY_PRESS_DELAY = 200;char operation = '!';float operand1 = 0, operand2 = 0, result = 0;short decCount = 0;// ***  Main Program  **********************************************************void main (){  init();  welcome();  while(1)  // Endless Loop  {      checkColumnOne();    // Check the first column of the keypad      checkColumnTwo();    // Check the second column of the keypad      checkColumnThree();  // Check the third column of the keypad      checkColumnFour();   // Check the fourth column of the keypad  }}// ***  Interupts  *************************************************************// clear_interupt -- Clears out the calculator upon user requestvoid clear_interupt(void) interrupt 4{  char chr = '\n';  RI = 0;      // Clear receive interrupt flag  chr = SBUF;  // Copy input buffer to chr  if (chr == 'c' || chr == 'C')  {    /* We were going to just call the clear function here, but in doing so,        uVision would throw warnings! */    // Clear the operands / operations / decCount    operation = '!';    operand1 = 0;    operand2 = 0;    decCount = 0;    // Put us on a new line for a new operation    sendCharToPC('\n');    sendCharToPC('\r');  }  return;}// ***  Functions  *************************************************************// init -- Initializes everything to get the board working properlyvoid init(void){  P1M1 = 0x00;    // Push pull except Rx  P0M1 = 0x00;    // Bidirectional  ES = 1;         // Enable UART Interrupt  EA = 1;         // Enable UART Interrupt  SCON = 0x50;    // Select BRG as UART Baud Rate Gen  SSTAT = 0x60;   // Separate Rx / Tx interrupts  BRGR0 = 0xF0;   // Setup BRG for 9600 baud @ 7.373MHz internal RC oscillator  BRGR1 = 0x02;  BRGCON = 0x03;  // Enable BRG  return;}// welcome -- Displays a welcome messagevoid welcome(void){  sendStringToPC("\n\r#######################################\n\r");  sendStringToPC("##                                   ##\n\r");  sendStringToPC("##          8051 Calculator          ##\n\r");  sendStringToPC("##                                   ##\n\r");  sendStringToPC("#######################################\n\n\r");  return;}// sendCharToPC -- Sends a single character to the computer screenvoid sendCharToPC(char chr){  TI = 0;       // Clear transmit interrupt flag  SBUF = chr;   // Send data  while (!TI);  // Wait until sent}// sendStringToPC -- Sends a string to the computer screenvoid sendStringToPC(char * str){  unsigned int i = 0;  // Send string one char at a time  while(str[i])  {    sendCharToPC(str[i]);    i++;  }}// delay -- Kills timevoid delay(unsigned short z){  unsigned short x, y;  for (x = 0; x < 250; x++)  {    for (y = 0; y < 250; y++)    {      for (z; z > 0; z--);    }  }  return;}// groundKeypad -- Sets all bits of the keypad to 1void groundKeypad(void){  KB0 = 1;  KB1 = 1;  KB2 = 1;  KB3 = 1;  KB4 = 1;  KB5 = 1;  KB6 = 1;  KB7 = 1;  return;}// checkColumnOne -- Checks the first column for inputsvoid checkColumnOne(void){  // Set the keypad up to look for buttons in the first column  groundKeypad();  KB0 = 0;    // Check for key press  if(!KB4)  {    saveOperand(1);  }  else if(!KB5)  {    saveOperand(2);  }  else if(!KB6)  {    saveOperand(3);  }  else if(!KB7)  {    saveOperation('+');  }  return;}// checkColumnTwo -- Checks the second column for inputsvoid checkColumnTwo(void){  // Set the keypad up to look for buttons in the second column  groundKeypad();  KB1 = 0;    // Check for key press  if(!KB4)  {    saveOperand(4);  }  else if(!KB5)  {    saveOperand(5);  }  else if(!KB6)  {    saveOperand(6);  }  else if(!KB7)  {    saveOperation('-');  }  return;}// checkColumnThree -- Checks the third column for inputsvoid checkColumnThree(void){  // Set the keypad up to look for buttons in the third column  groundKeypad();  KB2 = 0;    // Check for key press  if(!KB4)  {    saveOperand(7);  }  else if(!KB5)  {    saveOperand(8);  }  else if(!KB6)  {    saveOperand(9);  }  else if(!KB7)  {    saveOperation('*');  }  return;}// checkColumnFour -- Checks the fourth column for inputsvoid checkColumnFour(void){  // Set the keypad up to look for buttons in the fourth column  groundKeypad();  KB3 = 0;    // Check for key press  if(!KB4)  {    saveDecimal();  }  else if(!KB5)  {    saveOperand(0);  }  else if(!KB6)  {    equate();  }  else if(!KB7)  {    saveOperation('/');  }  return;}// clear -- Clears out the operands / operations / decCountvoid clear(void){  // Clear the operands / operations / decCount  operation = '!';  operand1 = 0;  operand2 = 0;  decCount = 0;  // Put us on a new line for a new operation  sendStringToPC("\n\r");  return;}// error -- Displays an error messagevoid error(char * message){  // Send error message  sendStringToPC("\n\rERROR: ");  sendStringToPC(message);  // Clear the operands / operations / decCount  clear();  return;}// saveDecimal -- Saves that a decimal was usedvoid saveDecimal(){  // Check that there wasn't already a decimal in this number  if (decCount != 0)  {    error("You may not have two decimal points in one number!");  }  else  {    // Output the decimal point and save that we are using it    sendCharToPC('.');    decCount = 1;  }  // Delay to prevent extra button presses  delay(KEY_PRESS_DELAY);  return;}// saveOperand -- Adds a new digit to the current operandvoid saveOperand(unsigned short operand){  // Check that we haven't gone too deep decimal wise  if (decCount == 3)  {    error("You may not have more than two digits past the decimal!");  }  else  {    // Output the current char to the screen    sendCharToPC(charValues[operand]);    // Update the value    if (decCount == 2)    {      operand2 += (operand / 100.0);      decCount++;    }    else if (decCount == 1)    {      operand2 += (operand / 10.0);      decCount++;    }    else    {      operand2 *= 10;      operand2 += operand;    }    // Unset the operation flag if set    if (operation == '=')    {      operation = '!';    }  }  // Delay to prevent extra button presses  delay(KEY_PRESS_DELAY);  return;}// saveOperation -- Saves the operation the user wished to dovoid saveOperation(char op){  // Check if we need to equate first  if (operation != '=' && operation != '!')  {    equate();  }  // Check if we need to use the value from the last result as an operand  if (operation == '=')  {    operand1 = result;       sendStringToPC(float_to_string(operand1));  }  // Else move this operand over and move on  else  {    operand1 = operand2;  }  decCount = 0;  operand2 = 0;  sendCharToPC(op);  operation = op;  // Delay to prevent extra button presses  delay(KEY_PRESS_DELAY);  return;}// equate -- Equates the current operations and operationvoid equate(void){  // Check that we haven't gone too deep decimal wise  if (operation == '=' || operation == '!')  {    error("Operation requires another operand!");  }  else if (operation == '/' && operand2 == 0)  {    error("Division by zero!  Are you trying to destory the universe!?");  }  else  {    // Perform the operation on the two operands    switch (operation)    {      case '+':        result = operand1 + operand2;        break;      case '-':        result = operand1 - operand2;        break;      case '*':        result = operand1 * operand2;        break;      case '/':        result = operand1 / operand2;        break;    }    // Output the result    sendCharToPC('=');    // Check for overflow    if (result > 32767 || result < -32767)    {      sendStringToPC("Overflow!");      // Clear out the system for the next operation      clear();    }    else    {      sendStringToPC(float_to_string(result));      // Clear out the system for the next operation      clear();      // Save an invalid operation into operation so we can check against it later      operation = '=';     }  }  // Delay to prevent extra button presses  delay(KEY_PRESS_DELAY);  return;}// float_to_string -- Converts a float to a string for outputchar * float_to_string(float val){  const short max = 10; // Needs to be updated 2 lines below (STUPID uVision!)  short i = max, j = 0;  char str[10];  int intpart = val;  char decimal = (val-intpart)*100;  // Check if the value is zero and output that  if (val == 0)  {    str[0] = '0';    j++;  }  else  {    // Check if the value is negative and save that into the string    if (val < 0)    {      intpart *= -1;      decimal *= -1;      str[j] = '-';      j++;    }    // Save the decimal into the string    if (decimal > 0)    {      str[i-1] = charValues[decimal%10];      str[i-2] = charValues[decimal/10];      str[i-3] = '.';      i -= 3;    }    // Save the interger into the string    while (intpart > 0 && i > 0)    {      i--;      str[i] = charValues[intpart%10];      intpart /= 10;    }    // Move the value up to the start of the string    while (i < max)    {      str[j] = str[i];      i++;      j++;    }  }  // Null terminate the end of the string  str[j] = '\0';  return str;}